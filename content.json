{"pages":[{"title":"","text":"{\"dependencies\":{\"hexo-generator-search\":\"^2.4.0\",\"hexo-prism-plugin\":\"^2.3.0\",\"hexo-server\":\"^1.0.0\",\"hexo-wordcount\":\"^6.0.1\"}}","link":"/package.json"},{"title":"about","text":"","link":"/about/index.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"friends","text":"","link":"/friends/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"Hello, Hexo","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new \"My New Post\" More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","link":"/2019/10/01/hello-world/"},{"title":"Trie树","text":"Trie 树，也叫做 字典树 、 前缀树 ，它有如下特点 根节点不包含字符，除根节点外每一个节点都只包含一个字符 从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串 每个节点的所有子节点包含的字符都不相同 class TrieNode &amp;#123; public char val; public boolean isWord; public TrieNode[] children = new TrieNode[26]; public TrieNode() &amp;#123;&amp;#125;; TrieNode( char c ) &amp;#123; TrieNode node = new TrieNode(); node.val = c; &amp;#125; &amp;#125; class Trie &amp;#123; &amp;#125;","link":"/2019/10/20/trie-shu/"},{"title":"冒泡排序","text":"1、基本概念冒泡排序是一种简单的排序方式。冒泡排序重复扫描待排序序列，比较每一对相邻元素，并在该对相邻元素顺序不正确时交换，重复这个过程直到没有任何两个相邻元素可以交换，此时整个序列被正确排序。 2、性质3、算法/** * 对元素进行比较 * 返回 true 说明 v 小于 w * 返回 false 说明 v 大于等于 w * @param v * @param w * @return */ public static boolean less(Comparable v, Comparable w)&amp;#123; return v.compareTo(w) &lt; 0 ; &amp;#125; /** * 交换 数组array 中 i，j 两个元素的位置 * @param array * @param i * @param j */ public static void exch(Comparable[] array, int i, int j)&amp;#123; Comparable t = array[i]; array[i] = array[j]; array[j] = t; &amp;#125; /** * * * @param array */ public static void bubbleSort(Comparable[] array) &amp;#123; int length = array.length; for (int i = 0; i &lt; length; i++) &amp;#123; for (int j = 1; j &lt; length-1-i; j++) &amp;#123; if (less(array[j], array[j-1])) &amp;#123; exch(array, j, j-1); &amp;#125; &amp;#125; &amp;#125; &amp;#125;","link":"/2019/10/04/mou-pao-pai-xu/"},{"title":"归并排序","text":"1、基本概念归并排序算法是一种基于比较的排序算法。它的基本思想是分治，对数组中下标从 l 到 r 中的数据进行排序时，首先根据中间位置 (l+r)/2 分成两半，然后递归分别对左边一半（ l 到 (l+r)/2 ）和 右边一半（ (l+r)/2+1 到 r ）进行归并排序，最后将两个已排序好的部分进行合并 2、性质3、算法/** * * @param array * @param start * @param end */ public static void mergeSort(Comparable[] array, int start, int end) &amp;#123; &amp;#125; 4、举例","link":"/2019/10/14/gui-bing-pai-xu/"},{"title":"快速排序","text":"1、基本概念快速排序是一种基于比较的排序算法，他的基本思想与归并排序类似，也是基于分治的。在递归过程中，通过选择一个基准数，将数组的一段分成比基准数小的和比基准数大的两个部分，然后递归分别对这两个部分排序。 2、性质快速排序算法是不稳定的 3、算法/** * 对元素进行比较 * 返回 true 说明 v 小于 w * 返回 false 说明 v 大于等于 w * @param v * @param w * @return */ public static boolean less(Comparable v, Comparable w)&amp;#123; return v.compareTo(w) &lt; 0 ; &amp;#125; /** * 交换 数组array 中 i，j 两个元素的位置 * @param array * @param i * @param j */ public static void exch(Comparable[] array, int i, int j)&amp;#123; Comparable t = array[i]; array[i] = array[j]; array[j] = t; &amp;#125; /** * * @param array * @param left * @param right * @return */ public static int partition(Comparable[] array, int left, int right) &amp;#123; int i = left, j = right+1; Comparable v = array[left]; while (true) &amp;#123; while (less(array[++i], v)) &amp;#123; if(i == right) &amp;#123; break; &amp;#125; &amp;#125; while (less(v, array[--j])) &amp;#123; if (j == left) &amp;#123; break; &amp;#125; &amp;#125; if (i >= j) &amp;#123; break; &amp;#125; exch(array, i, j); &amp;#125; exch(array, left, j); return j; &amp;#125; /** * * @param array * @param left * @param right */ public static void quickSort(Comparable[] array, int left, int right) &amp;#123; if (right &lt;= left) &amp;#123; return; &amp;#125; int j = partition(array, left, right); sort(array, left, j-1); sort(array, j+1, right); &amp;#125; 举例","link":"/2019/10/12/kuai-su-pai-xu/"},{"title":"插入排序","text":"1、基本概念插入排序是一种简单的排序方式，插入排序从前到后扫描待排序序列，并依次插入到已排序序列中的正确位置。 2、性质 插入排序是一种比较排序 插入排序属于稳定排序 插入排序可以在线进行，即在输入的同时进行排序 3、算法将数组中的数据分为两个区间，已排序区间 和 待排序区间，从前到后依次把 待排序区间中的第一个数 插入到 已排序区间 中的正确位置。 /** * 对元素进行比较 * 返回 true 说明 v 小于 w * 返回 false 说明 v 大于等于 w * @param v * @param w * @return */ public static boolean less(Comparable v, Comparable w)&amp;#123; return v.compareTo(w) &lt; 0 ; &amp;#125; /** * 交换 数组array 中 i，j 两个元素的位置 * @param array * @param i * @param j */ public static void exch(Comparable[] array, int i, int j)&amp;#123; Comparable t = array[i]; array[i] = array[j]; array[j] = t; &amp;#125; /** * 每次都将当前元素插入到左侧已经排序的数组中 * 使得插入之后左侧数组依然有序 * @param array */ public static void insertionSort(Compareable[] array) &amp;#123; int length = array.length; // 首先将array分为两部分，array[0]为已排序区间，array[1..length-1]为待排序区间 for (int i = 1; i &lt; length; i++) &amp;#123; // array[j-1] 大于 array[j] 才交换位置，保证了该排序的稳定排序 for (int j = i; j > 0 &amp;&amp; less(array[j], array[j-1]); j--) &amp;#123; exch(array, j, j-1); &amp;#125; &amp;#125; &amp;#125;","link":"/2019/10/06/cha-ru-pai-xu/"},{"title":"选择排序","text":"1、基本概念2、性质3、算法/** * 对元素进行比较 * 返回 true 说明 v 小于 w * 返回 false 说明 v 大于等于 w * @param v * @param w * @return */ public static boolean less(Comparable v, Comparable w)&amp;#123; return v.compareTo(w) &lt; 0 ; &amp;#125; /** * 交换 数组array 中 i，j 两个元素的位置 * @param array * @param i * @param j */ public static void exch(Comparable[] array, int i, int j)&amp;#123; Comparable t = array[i]; array[i] = array[j]; array[j] = t; &amp;#125; /** * * * @param array */ public void selectionSort(Comparable[] array) &amp;#123; int length = array.length; for (int i = 0; i &lt; length; i++) &amp;#123; int min = i; for (int j = i+1; j &lt; length; j++) &amp;#123; if (less(array[j], array[min])) &amp;#123; min = j; &amp;#125; &amp;#125; exch(array, i, min); &amp;#125; &amp;#125;","link":"/2019/10/10/xuan-ze-pai-xu/"}],"tags":[{"name":"字符串","slug":"字符串","link":"/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"排序","slug":"排序","link":"/tags/%E6%8E%92%E5%BA%8F/"}],"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]}